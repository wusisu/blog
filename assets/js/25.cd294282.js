(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{523:function(o,e,n){"use strict";n.r(e);var v=n(4),t=Object(v.a)({},(function(){var o=this,e=o.$createElement,n=o._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[n("p",[o._v("nodejs很适合做http数据服务器，用上express之类的框架很容易就搭出一套http service来。然后数据库感觉就跟mongodb很搭，这样子一套下来全都是javascript技术栈。但是nodejs跟mongodb之间的接口应该选择哪一个呢？")]),o._v(" "),n("p",[o._v("我关注到的库有两个："),n("a",{attrs:{href:"https://github.com/mongodb/node-mongodb-native",target:"_blank",rel:"noopener noreferrer"}},[o._v("node-mongodb-native"),n("OutboundLink")],1),o._v("和"),n("a",{attrs:{href:"https://github.com/Automattic/mongoose",target:"_blank",rel:"noopener noreferrer"}},[o._v("mongoose"),n("OutboundLink")],1),o._v("。")]),o._v(" "),n("p",[o._v("node-mongodb-native是mongodb的官方nodejs封装。其实应该说是简单封装。使用它的感觉就像是直接在shell里用"),n("code",[o._v("mongo")]),o._v("操作，特别的灵活以及效率。甚爱之。"),n("br"),o._v("\nmongoose是一个深封装的"),n("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84",target:"_blank",rel:"noopener noreferrer"}},[o._v("ORM"),n("OutboundLink")],1),o._v("库。需要像mysql设计表结构那样子设计Schema，然后把Schema具象为Model，然后可以面向对象的使用数据库了。")]),o._v(" "),n("hr"),o._v(" "),n("p",[o._v("我是更爱高效灵活地node-mongodb-native的，然而使用之有一点不好，就是：感觉这个项目的team并没有花多少心思和时间在这上面，更多地是应付的做了一个专业的封装。"),n("br"),o._v("\n我这是什么意思呢？"),n("br"),o._v("\nnode-mongodb-native库的封装很专业，但是文档是比较应付式的，阅读和资讯获取都挺难，至少我做了近一个月还是不知道web service应该怎样"),n("strong",[o._v("标准")]),o._v("地去连接数据库（应该说怎么用数据库，连接一次然后一直使用这个db呢；还是每次用"),n("code",[o._v("db.open")]),o._v("；"),n("code",[o._v("db.open")]),o._v("是不是表示从连接池里拿一个连接？）。其开发人员是从对接口的封装出发来做这个项目，而不是从用户使用的角度来开发和写文档。"),n("br"),o._v("\n我在网上看人家对这两者的比较时看到他们说，大概意思是使用node-mongodb-native会比较折腾。"),n("br"),o._v("\n我现在认为这里的折腾不是指写起来麻烦，而是没有响应的指导和合适的文档，许多事情需要去读源码，去做测试（这种测试还不好做，也许某种用法低并发的时候适用，多了就不行了）。")]),o._v(" "),n("p",[o._v("这个项目的开发人员总该知道怎样使用吧！你倒是做个demo或者在doc中写出来啊！你倒是告诉我是不是针对每一个http请求都应该发起一个db的connection啊！你告诉我是不是对每一个http请求不用发起新connection但是需要重新"),n("code",[o._v("db.open")]),o._v("啊！你不说谁知道在web service中应该怎么用这个库啊！！！文档里每一个demo都是连接数据库-打开db-写入-关闭连接。也是醉了。")]),o._v(" "),n("p",[o._v("最后的结果是遇到不知名原因的bug，一个"),n("code",[o._v("collection.find")]),o._v("返回的"),n("code",[o._v("promise")]),o._v("卡"),n("code",[o._v("pending")]),o._v("，然后找不到原因和答案，放弃之。")]),o._v(" "),n("hr"),o._v(" "),n("p",[o._v("mongoose这种把动态类型当作静态类型的思路其实我是不喜欢的（其实不是静态类型，只是做类型转换啦，我是说我不喜欢这样的思路而已）。就像我不喜欢微软的TypeSrcipt（包括ES6）给javascript弄上静态类型和class一样，人家javascript明明本身是基于prototype设计的，硬是弄上class搞毛！"),n("br"),o._v("\n但是mongoose的开发看来是熟知node-mongodb-native的源码的，这二次封装（在node-mongodb-native的基础上进行封装）然后提供了较为完善的文档，也算是一个合适的选择。")]),o._v(" "),n("p",[o._v("这里有两个点需要注意一下：")]),o._v(" "),n("ol",[n("li",[o._v("我现在使用的mongoose版本是4.2.5，其依赖"),n("code",[o._v('"mpromise": "0.5.4"')]),o._v("。也就是说mongoose返回的"),n("code",[o._v("Promise")]),o._v("是"),n("code",[o._v("mpromise")]),o._v("提供的promise实现，而这个promise实现实测不支持"),n("code",[o._v("promise.reject")]),o._v("方法。")]),o._v(" "),n("li",[o._v("同样是这个版本。我使用文档里说的方法"),n("code",[o._v("mongoose.model('User', userSchema);")]),o._v("注册Model。这个时候model是被注册到"),n("code",[o._v("mongoose.models")]),o._v("的。于是在"),n("code",[o._v("mocha -w")]),o._v("的时候，会出现"),n("code",[o._v("OverwriteModelError")]),o._v("，估计是"),n("code",[o._v("mocha -w")]),o._v("的时候里面的机制并不会清空"),n("code",[o._v("mongoose.models")]),o._v("，然后重载model注册模块，于是报错。根据"),n("a",{attrs:{href:"https://github.com/Automattic/mongoose/issues/1251",target:"_blank",rel:"noopener noreferrer"}},[o._v("issue#1251"),n("OutboundLink")],1),o._v("，网友提供的"),n("code",[o._v("mongoose.models = {};mongoose.modelSchemas = {};")]),o._v("似乎可以解决这个问题。比较逗的是"),n("strong",[o._v("aheckmann")]),o._v("拼死不认为这是一个bug，一直说我们用错了。没太注意看，不过也许用"),n("code",[o._v("connection.model('User', userSchema);")]),o._v("来注册也能解决这个问题，这也许是aheckmann的意思。")])])])}),[],!1,null,null,null);e.default=t.exports}}]);