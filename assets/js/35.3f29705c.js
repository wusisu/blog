(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{533:function(a,t,n){"use strict";n.r(t);var r=n(4),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("最近在全力学习什么叫做Java，什么叫做Spring，什么是Bean。随便写写想法。")]),a._v(" "),n("h2",{attrs:{id:"名词王国"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#名词王国"}},[a._v("#")]),a._v(" 名词王国")]),a._v(" "),n("p",[a._v("首先介绍这篇文章"),n("a",{attrs:{href:"http://lcwangchao.github.io/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/2012/07/02/excution_in_the_kingdom_of_nouns/",target:"_blank",rel:"noopener noreferrer"}},[a._v("名词王国里的死刑（翻译）"),n("OutboundLink")],1),a._v("，就尽了全力在嘲讽Java的唯对象化编程的。\n在学习Java的过程中，特别是现在在看一个不那么成熟，但已经比较庞大的项目，更加是心有同感。\n这是一切的前提。\n比如一个Restful处理OAuth的api，需要有一个OAuthController, OAuthProvider, OAuthService, OAuthConfig.....\n心累。")]),a._v(" "),n("h2",{attrs:{id:"松耦合"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#松耦合"}},[a._v("#")]),a._v(" 松耦合")]),a._v(" "),n("p",[a._v("Java的问题还不止名词滥用一个。\n另外一个问题是，耦合性过高的问题。为了解决这个问题，Java竭尽脑汁。\n出了Interface，这样，类之间就不那么需要互相依赖了。\n然而，还是需要有一个主控来调用他们，赋值使用的。\n最后是"),n("a",{attrs:{href:"https://spring.io/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Spring"),n("OutboundLink")],1),a._v("出来统一了天下。")]),a._v(" "),n("h2",{attrs:{id:"interface-vs-duck-test"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#interface-vs-duck-test"}},[a._v("#")]),a._v(" Interface vs Duck Test")]),a._v(" "),n("p",[a._v("其实Interface和Duck Test（鸭子方法）是一回事。\n鸭子方法解释为：『如果它看起来像鸭子，游泳像鸭子，叫声像鸭子，那么它可能就是只鸭子。』\nInterface就是在事先说好了鸭子应该长得像什么，然后有这些功能的都可以扮演鸭子。\n不知道所谓的AOP编程是不是指这个呢？存疑。")]),a._v(" "),n("h2",{attrs:{id:"spring-and-bean"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#spring-and-bean"}},[a._v("#")]),a._v(" Spring and Bean")]),a._v(" "),n("p",[a._v("看了一篇"),n("a",{attrs:{href:"http://www.cnblogs.com/vicis/p/4750473.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("博客"),n("OutboundLink")],1),a._v("，觉得是学Bean最好的方法。\n简单说就是自己最小化的模拟着做了一个Spring的Bean系统，而且还是最新的基于注解（annotation）的。\n我把它给实现并上传到"),n("a",{attrs:{href:"https://github.com/wusisu/java-spring-bean-annotation-learn",target:"_blank",rel:"noopener noreferrer"}},[a._v("github"),n("OutboundLink")],1),a._v("了。\n简单说，Spring自己有一个注册库。所有注解为Bean的，就是在里面注册了可以用的一个创建实例的方法。\n用@Autowired/@Resource/@Qualifier的，是由Spring控制着往里面装载实例的地方。\n以此达到上述的松耦合。\n但是实际上，实现的方式无非是通过『字符串』或者『类』，归根结底是采用了动态语言的性质。")]),a._v(" "),n("h2",{attrs:{id:"java-lang-reflect-vs-meta-programming"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-lang-reflect-vs-meta-programming"}},[a._v("#")]),a._v(" java.lang.reflect vs meta programming")]),a._v(" "),n("p",[a._v("有一段时间，Ruby的元编程火到到处都是。\n其实Java的反射也是一回事，只是废话比较多，语言比较臃肿。\n现在最新的注解，其实是依赖于反射的。")]),a._v(" "),n("h2",{attrs:{id:"java-vs-javascript"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-vs-javascript"}},[a._v("#")]),a._v(" Java vs JavaScript")]),a._v(" "),n("p",[a._v("实话实说，做JavaEE，感觉还不如用JavaScript写。\n当然，写nodejs其实对人的要求更高。\n但是JavaEE好臃肿，代码冗长，体积臃肿。\n相对比，我觉得Java是在细节和底层做了许多优化，比如『静态语言』这一项也看做是优化，而nodejs则是底层随便写。\n然而底层高效的Java如果不好好写顶端的话，就会变得很搞笑了。\n我想写Nodejs。")])])}),[],!1,null,null,null);t.default=e.exports}}]);